var documenterSearchIndex = {"docs":
[{"location":"#Emissions","page":"Home","title":"Emissions","text":"Documentation for Emissions.","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"For a complete walkthrough of the emissions processing workflow, see the Complete Tutorial. This tutorial demonstrates the entire workflow from raw EPA emissions data to gridded outputs using both synthetic examples and instructions for the full NEI dataset.\n\nFor detailed API documentation of all functions and types, see the API Reference.\n\n","category":"section"},{"location":"nei_processing/#NEI-Processing","page":"NEI Processing","title":"NEI Processing","text":"","category":"section"},{"location":"nei_processing/#Overview","page":"NEI Processing","title":"Overview","text":"The Emissions.jl package provides tools for processing EPA National Emissions Inventory (NEI) data. It supports reading FF10-format emissions files, spatial allocation using surrogate shapefiles, and gridding emissions to model-ready formats.\n\nThe package also includes plume rise calculations based on ASME (1973), as described in Seinfeld and Pandis, \"Atmospheric Chemistry and Physics - From Air Pollution to Climate Change\".","category":"section"},{"location":"nei_processing/#Plume-Rise","page":"NEI Processing","title":"Plume Rise","text":"The following functions implement the ASME (1973) plume rise algorithm:\n\nfindLayer - Find the model layer containing a given height\ncalcDeltaH - Calculate plume rise\nASME - Calculate effective emissions height with plume rise\ncalcDeltaHPrecomputed - Calculate plume rise with precomputed meteorological parameters\nASMEPrecomputed - Calculate effective emissions height with precomputed parameters","category":"section"},{"location":"nei_processing/#Constants-and-Unit-Conversions","page":"NEI Processing","title":"Constants and Unit Conversions","text":"","category":"section"},{"location":"nei_processing/#Data-Types","page":"NEI Processing","title":"Data Types","text":"","category":"section"},{"location":"nei_processing/#FF10-Data-Formats","page":"NEI Processing","title":"FF10 Data Formats","text":"The EPA FF10 (Flat File 10) format is the standard format for emissions inventory data. The package supports four FF10 format types:","category":"section"},{"location":"nei_processing/#I/O-Functions","page":"NEI Processing","title":"I/O Functions","text":"","category":"section"},{"location":"nei_processing/#Spatial-Processing","page":"NEI Processing","title":"Spatial Processing","text":"","category":"section"},{"location":"nei_processing/#Surrogate-Operations","page":"NEI Processing","title":"Surrogate Operations","text":"","category":"section"},{"location":"nei_processing/#Output","page":"NEI Processing","title":"Output","text":"","category":"section"},{"location":"nei_processing/#Emissions.tonperyear","page":"NEI Processing","title":"Emissions.tonperyear","text":"tonperyear\n\nConversion factor from tons per year to kg per second. 1 ton = 907.185 kg, 1 year = 31,536,000 seconds.\n\n\n\n\n\n","category":"constant"},{"location":"nei_processing/#Emissions.tonpermonth","page":"NEI Processing","title":"Emissions.tonpermonth","text":"tonpermonth\n\nConversion factor from tons per month to kg per second. 1 ton = 907.185 kg, 1 month = 2,628,288 seconds (average month).\n\n\n\n\n\n","category":"constant"},{"location":"nei_processing/#Emissions.foot","page":"NEI Processing","title":"Emissions.foot","text":"foot\n\nConversion factor from feet to meters. 1 foot = 0.3048 meters.\n\n\n\n\n\n","category":"constant"},{"location":"nei_processing/#Emissions.kelvin","page":"NEI Processing","title":"Emissions.kelvin","text":"kelvin(F)\n\nConvert temperature from Fahrenheit to Kelvin.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.Pollutants","page":"NEI Processing","title":"Emissions.Pollutants","text":"Pollutants\n\nDictionary mapping specific pollutant identifiers to aggregated pollutant group names.\n\n\n\n\n\n","category":"constant"},{"location":"nei_processing/#Emissions.EmissionsDataFrame","page":"NEI Processing","title":"Emissions.EmissionsDataFrame","text":"EmissionsDataFrame\n\nAbstract type for emissions data frames wrapping FF10 format data.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.SurrogateSpec","page":"NEI Processing","title":"Emissions.SurrogateSpec","text":"SurrogateSpec\n\nHolds surrogate specification data for spatial allocation of emissions.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.GridDef","page":"NEI Processing","title":"Emissions.GridDef","text":"GridDef\n\nSpecifies the grid that we are allocating the emissions to.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.SpatialProcessor","page":"NEI Processing","title":"Emissions.SpatialProcessor","text":"SpatialProcessor\n\nSpatializes emissions records using surrogate specifications and grid definitions.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.Config","page":"NEI Processing","title":"Emissions.Config","text":"Config\n\nHolds configuration data for the emissions processing pipeline.\n\nFields\n\nf_gridRef: Paths to grid reference files\nSrgSpec: Path to surrogate specification file\nSrgShapefileDirectory: Directory containing surrogate shapefiles\nInputSR: Input spatial reference (projection string)\nOutputSR: Output spatial reference (projection string)\nGridFile: Path to grid definition file\nGridName: Name of the grid\nCounties: Path to counties shapefile\nEmisShp: Path to output emissions shapefile directory\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.IndexInfo","page":"NEI Processing","title":"Emissions.IndexInfo","text":"IndexInfo\n\nHolds grid index information for gridded emissions, including which grid cells a source maps to and the fraction of emissions allocated to each cell.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.FF10NonPointDataFrame","page":"NEI Processing","title":"Emissions.FF10NonPointDataFrame","text":"FF10NonPointDataFrame <: EmissionsDataFrame\n\nWrapper for EPA FF10 nonpoint emissions data. Validates that the DataFrame has 45 columns, renames them to standard names, standardizes FIPS/SCC codes, and converts units.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.FF10PointDataFrame","page":"NEI Processing","title":"Emissions.FF10PointDataFrame","text":"FF10PointDataFrame <: EmissionsDataFrame\n\nWrapper for EPA FF10 point source emissions data. Validates that the DataFrame has 77 columns, renames them to standard names, standardizes FIPS/SCC codes, converts units, and converts stack parameters from imperial to SI units.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.FF10NonRoadDataFrame","page":"NEI Processing","title":"Emissions.FF10NonRoadDataFrame","text":"FF10NonRoadDataFrame <: EmissionsDataFrame\n\nWrapper for EPA FF10 nonroad emissions data. Uses the same format as nonpoint.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.FF10OnRoadDataFrame","page":"NEI Processing","title":"Emissions.FF10OnRoadDataFrame","text":"FF10OnRoadDataFrame <: EmissionsDataFrame\n\nWrapper for EPA FF10 on-road emissions data. Uses the same format as nonpoint.\n\n\n\n\n\n","category":"type"},{"location":"nei_processing/#Emissions.strip_missing","page":"NEI Processing","title":"Emissions.strip_missing","text":"strip_missing(df::DataFrame)\n\nReplace all missing values in a DataFrame with empty strings.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.getCountry","page":"NEI Processing","title":"Emissions.getCountry","text":"getCountry(fips::AbstractString)\n\nReturn the country name based on the first digit of the FIPS code.\n\n'0' or '9' => \"US\"\n'1' => \"Mexico\"\n'2' => \"Canada\"\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.read_grid","page":"NEI Processing","title":"Emissions.read_grid","text":"read_grid(file::AbstractString)\n\nRead a grid definition file (IOAPI-style GRIDDESC format) and return a DataFrame with columns FIPS, Longitude, and Latitude.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.getShapefilePath","page":"NEI Processing","title":"Emissions.getShapefilePath","text":"getShapefilePath(dir::AbstractString, name::AbstractString, check::Bool=true)\n\nFind the full path to a shapefile within the given directory tree. Searches recursively for files with .shp extension matching the given name.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.validateShapefile","page":"NEI Processing","title":"Emissions.validateShapefile","text":"validateShapefile(path::AbstractString)\n\nCheck that a shapefile path is non-empty and the file exists.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.readSrgSpecSMOKE","page":"NEI Processing","title":"Emissions.readSrgSpecSMOKE","text":"readSrgSpecSMOKE(file::AbstractString, SrgShapefileDirectory::AbstractString, CheckShapefiles::Bool=false)\n\nRead a SMOKE-format spatial surrogate specification file and return a vector of SurrogateSpec objects.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.NewSpatialProcessor","page":"NEI Processing","title":"Emissions.NewSpatialProcessor","text":"NewSpatialProcessor(srgSpecs, grids, gridRef, inputSR, matchFullSCC)\n\nCreate a new SpatialProcessor with default cache and merge depth settings.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.NewPolygon","page":"NEI Processing","title":"Emissions.NewPolygon","text":"NewPolygon(coords::Vector{Tuple{Float64,Float64}})\n\nCreate a LibGEOS polygon from a vector of coordinate tuples. The polygon is automatically closed if needed.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.NewGridIrregular","page":"NEI Processing","title":"Emissions.NewGridIrregular","text":"NewGridIrregular(name, nx, ny, sr, dx, dy, x0, y0)\n\nCreate a GridDef with a regular (but potentially projected) grid.\n\n\n\n\n\nNewGridIrregular(name, filepath, inputSR, outputSR)\n\nCreate an irregular grid by reading polygon coordinates from a file. The file should contain polygon coordinate strings in the format used by the NEI processing notebook.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.setupSpatialProcessor","page":"NEI Processing","title":"Emissions.setupSpatialProcessor","text":"setupSpatialProcessor(config::Config)\n\nSet up a SpatialProcessor from a configuration object. Reads grid reference files, surrogate specifications, and grid definitions.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.findCountyPolygon","page":"NEI Processing","title":"Emissions.findCountyPolygon","text":"findCountyPolygon(fips::AbstractString, countyShapefile::AbstractString)\n\nFind and return the polygon for a given FIPS code from a county shapefile.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.GetIndex","page":"NEI Processing","title":"Emissions.GetIndex","text":"GetIndex(point_or_poly, grid::GridDef)\n\nFind which grid cells a point or polygon intersects, and return an IndexInfo with the row/column indices and fractional coverage.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.recordToGrid","page":"NEI Processing","title":"Emissions.recordToGrid","text":"recordToGrid(emissions::Float64, index::IndexInfo, grid_nx::Int, grid_ny::Int)\n\nDistribute emissions to grid cells according to the fractional coverage in IndexInfo. Returns a sparse matrix of emissions.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.GridFactors","page":"NEI Processing","title":"Emissions.GridFactors","text":"GridFactors(grid::GridDef)\n\nReturn a matrix of grid cell areas.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.uniqueCoordinates","page":"NEI Processing","title":"Emissions.uniqueCoordinates","text":"uniqueCoordinates(lons::Vector{Float64}, lats::Vector{Float64})\n\nReturn the indices of unique (lon, lat) coordinate pairs.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.uniqueLoc","page":"NEI Processing","title":"Emissions.uniqueLoc","text":"uniqueLoc(lons::Vector{Float64}, lats::Vector{Float64})\n\nReturn a dictionary mapping unique (lon, lat) pairs to their first occurrence index.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.generate_data_sparse_matrices","page":"NEI Processing","title":"Emissions.generate_data_sparse_matrices","text":"generate_data_sparse_matrices(shapefile_path, attribute, grid, inputSR)\n\nRead a data shapefile and generate sparse matrices representing the spatial allocation of each region (identified by attribute) to grid cells. Returns a dictionary mapping attribute values to sparse matrices.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.generate_weight_sparse_matrices","page":"NEI Processing","title":"Emissions.generate_weight_sparse_matrices","text":"generate_weight_sparse_matrices(shapefile_path, weight_columns, weight_factors, grid, inputSR)\n\nRead a weight shapefile and generate sparse matrices of weighted values on the grid.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.generate_grid_sparse_matrices","page":"NEI Processing","title":"Emissions.generate_grid_sparse_matrices","text":"generate_grid_sparse_matrices(grid::GridDef)\n\nGenerate a sparse matrix of grid cell areas.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.generate_countySurrogate","page":"NEI Processing","title":"Emissions.generate_countySurrogate","text":"generate_countySurrogate(data_matrices, weight_matrix, grid_matrix)\n\nGenerate a surrogate matrix by combining data and weight matrices. For each region in data_matrices, the surrogate is computed as:   surrogate = (data .* weight) / sum(data .* weight) Falls back to area-based allocation if weight sum is zero.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.update_locIndex","page":"NEI Processing","title":"Emissions.update_locIndex","text":"update_locIndex(locIndex::Dict, fips::AbstractString, surrogates::Dict)\n\nUpdate a location index dictionary with surrogate allocation data for a given FIPS code. Returns the IndexInfo for the FIPS code from the surrogates, or a default empty IndexInfo.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.find_surrogate_by_code","page":"NEI Processing","title":"Emissions.find_surrogate_by_code","text":"find_surrogate_by_code(srgSpecs::Vector{SurrogateSpec}, code::Int)\n\nFind a surrogate specification by its code number. Returns the matching SurrogateSpec or nothing if not found.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.get_data_weight_shapefiles","page":"NEI Processing","title":"Emissions.get_data_weight_shapefiles","text":"get_data_weight_shapefiles(srg::SurrogateSpec)\n\nReturn a tuple of (datashapefile, weightshapefile) paths from a surrogate specification.\n\n\n\n\n\n","category":"function"},{"location":"nei_processing/#Emissions.writeEmis","page":"NEI Processing","title":"Emissions.writeEmis","text":"writeEmis(filename, grid_data, grid::GridDef; pollutant=\"\", units=\"\")\n\nWrite gridded emissions data to a CSV file.\n\nArguments\n\nfilename: Output file path\ngrid_data: Matrix or sparse matrix of emissions values\ngrid: Grid definition\npollutant: Pollutant name (optional, for header)\nunits: Units string (optional, for header)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Complete-Tutorial","page":"Complete Tutorial","title":"Complete Tutorial","text":"This tutorial demonstrates the complete workflow for processing EPA National Emissions Inventory (NEI) data using Emissions.jl, from raw FF10 files to gridded, spatially-allocated outputs.","category":"section"},{"location":"tutorial/#Overview","page":"Complete Tutorial","title":"Overview","text":"The emissions processing workflow consists of several key steps:\n\nSetup: Configuration and data paths\nLoad: Read FF10 format emissions files\nAggregate: Combine and sum emissions by location and source\nFilter: Keep only known pollutants and apply quality filters\nSpatial Setup: Initialize spatial processing components\nGrid Reference: Assign spatial surrogates to emissions\nSpatial Allocation: Generate allocation matrices from shapefiles\nOutput: Write gridded emissions to shapefile\n\nThis tutorial shows two approaches: a synthetic data example for learning and testing, and instructions for processing the full NEI dataset.","category":"section"},{"location":"tutorial/#Synthetic-Data-Walkthrough","page":"Complete Tutorial","title":"Synthetic Data Walkthrough","text":"The following example demonstrates the complete workflow using synthetic data that can be run without downloading large datasets.\n\nusing Emissions\nusing DataFrames\nusing CSV\nusing Printf\nusing Unitful\n\n# =============================================================================\n# Step 1: Create Synthetic Emissions Data\n# =============================================================================\nprintln(\"=== Step 1: Creating Synthetic Emissions Data ===\")\n\n# Create synthetic data matching exact FF10 nonpoint format (45 columns)\nsynthetic_data = DataFrame(\n    COUNTRY = [\"0\", \"0\", \"0\", \"0\"],\n    FIPS = [\"36001\", \"36001\", \"36005\", \"36005\"],\n    TRIBAL_CODE = [\"0\", \"0\", \"0\", \"0\"],\n    CENSUS_TRACT = [\"0\", \"0\", \"0\", \"0\"],\n    SHAPE_ID = [\"0\", \"0\", \"0\", \"0\"],\n    SCC = [\"2103007000\", \"2103007000\", \"2103007000\", \"2103007000\"],\n    EMIS_TYPE = [\"\", \"\", \"\", \"\"],\n    POLID = [\"NOX\", \"VOC\", \"NOX\", \"VOC\"],                       # Pollutant ID\n    ANN_VALUE = [150.5, 75.2, 200.1, 125.8],                   # tons/year\n    ANN_PCT_RED = [0.0, 0.0, 0.0, 0.0],\n    CONTROL_IDS = [\"\", \"\", \"\", \"\"],\n    CONTROL_MEASURES = [\"\", \"\", \"\", \"\"],\n    CURRENT_COST = [0.0, 0.0, 0.0, 0.0],\n    CUMULATIVE_COST = [0.0, 0.0, 0.0, 0.0],\n    PROJECTION_FACTOR = [1.0, 1.0, 1.0, 1.0],\n    REG_CODES = [\"\", \"\", \"\", \"\"],\n    CALC_METHOD = [1, 1, 1, 1],\n    CALC_YEAR = [2019, 2019, 2019, 2019],\n    DATE_UPDATED = [\"\", \"\", \"\", \"\"],\n    DATA_SET_ID = [\"\", \"\", \"\", \"\"],\n    JAN_VALUE = [0.0, 0.0, 0.0, 0.0],\n    FEB_VALUE = [0.0, 0.0, 0.0, 0.0],\n    MAR_VALUE = [0.0, 0.0, 0.0, 0.0],\n    APR_VALUE = [0.0, 0.0, 0.0, 0.0],\n    MAY_VALUE = [0.0, 0.0, 0.0, 0.0],\n    JUN_VALUE = [0.0, 0.0, 0.0, 0.0],\n    JUL_VALUE = [0.0, 0.0, 0.0, 0.0],\n    AUG_VALUE = [0.0, 0.0, 0.0, 0.0],\n    SEP_VALUE = [0.0, 0.0, 0.0, 0.0],\n    OCT_VALUE = [0.0, 0.0, 0.0, 0.0],\n    NOV_VALUE = [0.0, 0.0, 0.0, 0.0],\n    DEC_VALUE = [0.0, 0.0, 0.0, 0.0],\n    JAN_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    FEB_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    MAR_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    APR_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    MAY_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    JUN_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    JUL_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    AUG_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    SEP_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    OCT_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    NOV_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    DEC_PCTRED = [0.0, 0.0, 0.0, 0.0],\n    COMMENT = [\"Synthetic example\", \"Synthetic example\", \"Synthetic example\", \"Synthetic example\"]\n)\n\nprintln(\"Created synthetic emissions with $(nrow(synthetic_data)) records and $(ncol(synthetic_data)) columns\")\nprintln(\"First few rows:\")\nshow(first(synthetic_data[!, 1:8], 4), allcols=true)  # Show first 8 columns\n\n# =============================================================================\n# Step 2: Load Emissions with FF10 Format Validation\n# =============================================================================\nprintln(\"\\n\\n=== Step 2: Loading Emissions with FF10 Format Validation ===\")\n\n# The FF10NonPointDataFrame constructor validates structure and converts units\nff10_data = FF10NonPointDataFrame(synthetic_data)\nprocessed_emis = ff10_data.df\nprintln(\"✅ Successfully loaded and validated FF10 nonpoint data\")\nprintln(\"Shape: $(nrow(processed_emis)) rows × $(ncol(processed_emis)) columns\")\n\n# Show the unit conversion in action\nprintln(\"\\nUnit conversion examples:\")\nprintln(\"Original tons/year: $(synthetic_data[1, :ANN_VALUE])\")\nprintln(\"Converted to kg/s: $(processed_emis[1, :ANN_VALUE])\")\n@printf \"Conversion factor: %.2e kg/s per ton/year\\n\" (processed_emis[1, :ANN_VALUE] / synthetic_data[1, :ANN_VALUE])\n\n# =============================================================================\n# Step 3: Aggregating and Filtering Emissions\n# =============================================================================\nprintln(\"\\n\\n=== Step 3: Aggregating and Filtering Emissions ===\")\n\n# Group by key fields and sum emissions (this removes duplicates)\ngrouped_emis = combine(\n    groupby(processed_emis, [:POLID, :COUNTRY, :FIPS, :SCC]),\n    :ANN_VALUE => sum => :ANN_VALUE\n)\n\nprintln(\"After grouping: $(nrow(grouped_emis)) unique emission records\")\nshow(grouped_emis, allcols=true)\n\n# Filter to keep only known pollutants\nknown_polls = filter(row -> haskey(Pollutants, row.POLID), grouped_emis)\nprintln(\"\\n\\nKnown pollutants found: $(nrow(known_polls)) records\")\n\n# Map to standard pollutant names\nknown_polls[!, :POLID] = [Pollutants[p] for p in known_polls[!, :POLID]]\nprintln(\"Mapped to standard names:\")\nshow(known_polls, allcols=true)\n\n# =============================================================================\n# Step 4: Create Supporting Data Structures\n# =============================================================================\nprintln(\"\\n\\n=== Step 4: Setting Up Spatial Processing Configuration ===\")\n\n# Create synthetic grid reference data\ngrid_ref = DataFrame(\n    COUNTRY = [\"USA\", \"USA\", \"USA\"],\n    FIPS = [\"36001\", \"36005\", \"00000\"],  # Include fallback (00000) surrogate\n    SCC = [\"2103007000\", \"2103007000\", \"2103007000\"],\n    Surrogate = [100, 100, 100]  # All use surrogate code 100\n)\n\n# Create synthetic surrogate specification\nsrg_spec = SurrogateSpec(\n    \"USA\",                    # Region\n    \"Population\",             # Name\n    100,                      # Code\n    \"population.shp\",         # DataShapefile\n    \"POP2019\",               # DataAttribute\n    \"area.shp\",              # WeightShapefile\n    \"Area-based allocation\",  # Details\n    String[],                # BackupSurrogateNames\n    [\"AREA\"],                # WeightColumns\n    [1.0],                   # WeightFactors\n    \"\",                      # FilterFunction\n    String[],                # MergeNames\n    Float64[]                # MergeMultipliers\n)\n\n# Create synthetic configuration (in real use, these would be actual file paths)\nconfig = Config(\n    [\"/tmp/synthetic_gridref.csv\"],      # f_gridRef\n    \"/tmp/synthetic_srgspec.csv\",        # SrgSpec\n    \"/tmp/shapefiles/\",                  # SrgShapefileDirectory\n    \"+proj=longlat +datum=WGS84\",        # InputSR\n    \"+proj=lcc +lat_1=33 +lat_2=45\",     # OutputSR\n    \"/tmp/synthetic_grid.txt\",           # GridFile\n    \"SyntheticGrid\",                     # GridName\n    \"/tmp/counties.shp\",                 # Counties\n    \"/tmp/output/\"                       # EmisShp\n)\n\nprintln(\"Grid Reference data:\")\nshow(grid_ref, allcols=true)\n\nprintln(\"\\n\\nSurrogate Specifications:\")\nprintln(\"Surrogate $(srg_spec.Code): $(srg_spec.Name)\")\nprintln(\"  Data: $(srg_spec.DataShapefile) [$(srg_spec.DataAttribute)]\")\nprintln(\"  Weight: $(srg_spec.WeightShapefile) [$(join(srg_spec.WeightColumns, \", \"))]\")\nprintln(\"  Details: $(srg_spec.Details)\")\n\nprintln(\"\\n\\nConfiguration:\")\nprintln(\"Input projection: $(config.InputSR)\")\nprintln(\"Output projection: $(config.OutputSR)\")\nprintln(\"Grid name: $(config.GridName)\")\n\n# =============================================================================\n# Step 5: Assign Spatial Surrogates\n# =============================================================================\nprintln(\"\\n\\n=== Step 5: Assigning Spatial Surrogates ===\")\n\n# POLID column already matches grid reference format (no renaming needed)\n\n# Join with grid reference to assign surrogates\nemissions_with_surrogates = leftjoin(\n    known_polls,\n    grid_ref,\n    on = [:COUNTRY, :FIPS, :SCC]\n)\n\nprintln(\"Emissions with assigned surrogates:\")\nshow(emissions_with_surrogates, allcols=true)\n\n# Check for unmatched emissions (would need fallback surrogates in real data)\nunmatched = filter(row -> ismissing(row.Surrogate), emissions_with_surrogates)\nprintln(\"\\nUnmatched emissions requiring fallback surrogates: $(nrow(unmatched))\")\n\nif nrow(unmatched) > 0\n    println(\"In real processing, these would be matched against FIPS='00000' records\")\nend\n\n# =============================================================================\n# Step 6: Demonstrate Key Constants and Unit Conversions\n# =============================================================================\nprintln(\"\\n\\n=== Step 6: Key Constants and Unit Conversions ===\")\n\nprintln(\"Emissions unit conversion factors:\")\n@printf \"tons/year → kg/s: %.2e\\n\" ustrip(tonperyear)\n@printf \"tons/month → kg/s: %.2e\\n\" ustrip(tonpermonth)\n@printf \"feet → meters: %.4f\\n\" ustrip(foot)\n\nprintln(\"\\nTemperature conversion examples:\")\ntemps_f = [32.0, 68.0, 212.0]  # Freezing, room temp, boiling\nfor temp_f in temps_f\n    temp_k = kelvin(temp_f)\n    @printf \"%.1f°F = %.2f K\\n\" temp_f ustrip(temp_k)\nend\n\nprintln(\"\\nSupported pollutants:\")\nfor (ff10_name, standard_name) in pairs(Pollutants)\n    println(\"  $ff10_name → $standard_name\")\nend\n\n# =============================================================================\n# Step 7: Spatial Processing Workflow Overview\n# =============================================================================\nprintln(\"\\n\\n=== Step 7: Spatial Processing Workflow (Conceptual) ===\")\n\nprintln(\"\"\"\nThe complete spatial processing workflow would continue with:\n\n1. **Shapefile Loading**: Read population and area shapefiles\n   - generate_data_sparse_matrices() for population data\n   - generate_weight_sparse_matrices() for area weights\n   - generate_grid_sparse_matrices() for target grid\n\n2. **Surrogate Generation**:\n   - generate_countySurrogate() combines data and weights\n   - Creates normalized allocation fractions that sum to 1.0\n\n3. **Location Indexing**:\n   - GetIndex() finds grid cells for each emission location\n   - Handles partial grid cell coverage with fractions\n\n4. **Final Allocation**:\n   - recordToGrid() distributes emissions to grid cells\n   - Applies surrogate fractions and location fractions\n\n5. **Output Generation**:\n   - writeEmis() creates final gridded shapefile\n   - Includes emission amounts, grid coordinates, metadata\n\"\"\")\n\n# Show what the final output structure would look like\nfinal_output_structure = DataFrame(\n    GridCell = [1, 1, 2, 2],\n    Pollutant = [\"NOX\", \"VOC\", \"NOX\", \"VOC\"],\n    EmissionRate_kg_s = [1.2e-6, 6.1e-7, 1.6e-6, 1.0e-6],\n    SourceCount = [2, 2, 2, 2],\n    County = [\"36001\", \"36001\", \"36005\", \"36005\"]\n)\n\nprintln(\"Final gridded output structure:\")\nshow(final_output_structure, allcols=true)\n\nprintln(\"\\n✅ Synthetic workflow demonstration complete!\")","category":"section"},{"location":"tutorial/#Processing-the-Full-NEI-Dataset","page":"Complete Tutorial","title":"Processing the Full NEI Dataset","text":"For processing the complete EPA National Emissions Inventory, follow these steps:","category":"section"},{"location":"tutorial/#Step-1:-Download-NEI-Data","page":"Complete Tutorial","title":"Step 1: Download NEI Data","text":"# The full NEI dataset can be downloaded from EPA's website:\n# https://www.epa.gov/air-emissions-inventories/2019-national-emissions-inventory-nei-data\n\n# Example file structure for 2019 NEI:\nnei_base_url = \"https://gaftp.epa.gov/air/nei/2019/\"\nfile_downloads = [\n    \"nonpoint/2019v1_nonpoint_20210121_csv.zip\",\n    \"point/2019v1_point_20210121_csv.zip\",\n    \"nonroad/2019v1_nonroad_20210121_csv.zip\",\n    \"onroad/2019v1_onroad_20210121_csv.zip\"\n]\n\n# Download and extract files\nusing HTTP, ZipFile\nfor file in file_downloads\n    url = nei_base_url * file\n    local_path = joinpath(\"data\", \"nei2019\", basename(file))\n\n    # Download\n    println(\"Downloading: $url\")\n    HTTP.download(url, local_path)\n\n    # Extract ZIP file\n    zip_reader = ZipFile.Reader(local_path)\n    for file_info in zip_reader.files\n        # Extract CSV files to data directory\n        if endswith(file_info.name, \".csv\")\n            extracted_path = joinpath(\"data\", \"nei2019\", file_info.name)\n            open(extracted_path, \"w\") do io\n                write(io, read(file_info))\n            end\n            println(\"  Extracted: $(file_info.name)\")\n        end\n    end\n    close(zip_reader)\nend","category":"section"},{"location":"tutorial/#Step-2:-Set-Up-Real-Configuration","page":"Complete Tutorial","title":"Step 2: Set Up Real Configuration","text":"# Configure paths for full NEI processing\nreal_config = Config(\n    # Grid reference files (multiple regions)\n    [\n        \"data/spatial/gridref_usa_2019.csv\",\n        \"data/spatial/gridref_canada_2019.csv\",\n        \"data/spatial/gridref_mexico_2019.csv\"\n    ],\n\n    # Surrogate specification file\n    \"data/spatial/surrogate_specification_2019.csv\",\n\n    # Directory containing all spatial surrogate shapefiles\n    \"data/spatial/shapefiles/\",\n\n    # Input coordinate system (geographic coordinates)\n    \"+proj=longlat +datum=WGS84 +no_defs\",\n\n    # Output coordinate system (Lambert Conformal Conic for US modeling)\n    \"+proj=lcc +lat_1=33 +lat_2=45 +lat_0=40 +lon_0=-97 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n    # Grid definition file (defines target modeling grid)\n    \"data/grids/inmap_conus_grid.txt\",\n\n    # Grid identifier\n    \"InMAP_CONUS\",\n\n    # County boundaries shapefile\n    \"data/spatial/shapefiles/tl_2019_us_county.shp\",\n\n    # Output directory for gridded emissions\n    \"output/nei2019_gridded/\"\n)","category":"section"},{"location":"tutorial/#Step-3:-Process-Full-Dataset-by-Sector","page":"Complete Tutorial","title":"Step 3: Process Full Dataset by Sector","text":"# Define readers for each emission sector\nreaders = Dict(\n    \"nonpoint\" => (f -> FF10NonPointDataFrame(CSV.read(f, DataFrame, comment=\"#\"))),\n    \"point\" => (f -> FF10PointDataFrame(CSV.read(f, DataFrame, comment=\"#\"))),\n    \"nonroad\" => (f -> FF10NonRoadDataFrame(CSV.read(f, DataFrame, comment=\"#\"))),\n    \"onroad\" => (f -> FF10OnRoadDataFrame(CSV.read(f, DataFrame, comment=\"#\")))\n)\n\n# Process each sector separately to manage memory\nall_emissions = DataFrame[]\n\nfor (sector, reader) in readers\n    println(\"Processing $sector emissions...\")\n\n    # Find all CSV files for this sector\n    sector_files = filter(f -> contains(f, sector) && endswith(f, \".csv\"),\n                         readdir(\"data/nei2019/\", join=true))\n\n    sector_emissions = DataFrame[]\n    for file in sector_files\n        println(\"  Reading: $(basename(file))\")\n        try\n            ff10_data = reader(file)\n            push!(sector_emissions, ff10_data.df)\n        catch e\n            println(\"    Warning: Error reading $file: $e\")\n        end\n    end\n\n    # Concatenate all files in this sector\n    if !isempty(sector_emissions)\n        sector_combined = vcat(sector_emissions...)\n        println(\"  $sector total: $(nrow(sector_combined)) records\")\n        push!(all_emissions, sector_combined)\n    end\nend\n\n# Combine all sectors\nprintln(\"Combining all emission sectors...\")\ncombined_emissions = vcat(all_emissions...)\nprintln(\"Total emissions: $(nrow(combined_emissions)) records\")","category":"section"},{"location":"tutorial/#Step-4:-Full-Spatial-Processing","page":"Complete Tutorial","title":"Step 4: Full Spatial Processing","text":"# Initialize spatial processing for the full domain\nsp, gd = setupSpatialProcessor(real_config)\n\n# Aggregate emissions by location and source characteristics\naggregated = combine(\n    groupby(combined_emissions, [:POLID, :COUNTRY, :FIPS, :SCC, :LON, :LAT]),\n    :ANN_VALUE => sum => :ANN_VALUE,\n    :STACK_HEIGHT => mean => :STACK_HEIGHT,  # For point sources\n    :STACK_DIAMETER => mean => :STACK_DIAMETER,\n    :STACK_TEMP => mean => :STACK_TEMP,\n    :STACK_FLOW => sum => :STACK_FLOW,\n    :STACK_VELOCITY => mean => :STACK_VELOCITY\n)\n\n# Filter to known pollutants and standardize names\nknown_emis = filter(row -> haskey(Pollutants, row.POLID), aggregated)\nknown_emis[!, :POLID] = [Pollutants[p] for p in known_emis[!, :POLID]]\n\n# Join with grid reference to assign surrogates\nemissions_with_surrogates = leftjoin(known_emis, sp.GridRef, on=[:COUNTRY, :FIPS, :SCC])\n\n# Handle fallback surrogates for unmatched emissions\nunmatched = filter(row -> ismissing(row.Surrogate), emissions_with_surrogates)\nif nrow(unmatched) > 0\n    # Try fallback with FIPS = \"00000\" (statewide surrogates)\n    fallback_ref = filter(row -> row.FIPS == \"00000\", sp.GridRef)\n\n    # Match unmatched emissions with fallback surrogates\n    unmatched_fallback = leftjoin(\n        select(unmatched, Not(:Surrogate)),\n        select(fallback_ref, [:COUNTRY, :SCC, :Surrogate => :FallbackSurrogate]),\n        on = [:COUNTRY, :SCC]\n    )\n    unmatched_fallback[!, :Surrogate] = unmatched_fallback[!, :FallbackSurrogate]\n    select!(unmatched_fallback, Not(:FallbackSurrogate))\n\n    # Combine matched and fallback-matched emissions\n    matched = filter(row -> !ismissing(row.Surrogate), emissions_with_surrogates)\n    final_emissions = vcat(matched, unmatched_fallback)\nelse\n    final_emissions = emissions_with_surrogates\nend\n\nprintln(\"Final emissions ready for spatial allocation: $(nrow(final_emissions)) records\")","category":"section"},{"location":"tutorial/#Step-5:-Generate-Full-Spatial-Allocation","page":"Complete Tutorial","title":"Step 5: Generate Full Spatial Allocation","text":"# Define processing domain bounds (full CONUS)\nconus_bounds = (\n    x_min = -130.0,  # Western boundary\n    x_max = -65.0,   # Eastern boundary\n    y_min = 20.0,    # Southern boundary\n    y_max = 55.0     # Northern boundary\n)\n\nresolution = 0.01  # ~1km resolution\n\n# Generate sparse matrices for all shapefiles used in surrogates\nprintln(\"Generating spatial allocation matrices...\")\n\nall_sparse_data = Dict()\nall_sparse_weight = Dict()\n\nfor spec in sp.SrgSpecs\n    println(\"Processing surrogate $(spec.Code): $(spec.Name)\")\n\n    # Generate data matrices\n    if !haskey(all_sparse_data, spec.DataShapefile)\n        data_matrices = generate_data_sparse_matrices(\n            conus_bounds.x_min, conus_bounds.x_max,\n            conus_bounds.y_min, conus_bounds.y_max,\n            resolution,\n            joinpath(real_config.SrgShapefileDirectory, spec.DataShapefile),\n            spec.DataAttribute\n        )\n        all_sparse_data[spec.DataShapefile] = data_matrices\n    end\n\n    # Generate weight matrices\n    if !haskey(all_sparse_weight, spec.WeightShapefile)\n        weight_matrices = generate_weight_sparse_matrices(\n            conus_bounds.x_min, conus_bounds.x_max,\n            conus_bounds.y_min, conus_bounds.y_max,\n            resolution,\n            joinpath(real_config.SrgShapefileDirectory, spec.WeightShapefile),\n            spec.WeightColumns[1];  # Use first weight column\n            Filter = spec.FilterFunction\n        )\n        all_sparse_weight[spec.WeightShapefile] = weight_matrices\n    end\nend","category":"section"},{"location":"tutorial/#Step-6:-Write-Final-Output","page":"Complete Tutorial","title":"Step 6: Write Final Output","text":"# Generate county surrogates for all combinations\ncounty_surrogates = Dict()\nfor spec in sp.SrgSpecs\n    key = (spec.DataShapefile, spec.WeightShapefile)\n    if !haskey(county_surrogates, key)\n        county_surrogates[key] = generate_countySurrogate(\n            all_sparse_data[spec.DataShapefile],\n            all_sparse_weight[spec.WeightShapefile]\n        )\n    end\nend\n\n# For each unique emission location, create spatial index\nunique_locations = unique(select(final_emissions, [:COUNTRY, :FIPS, :LON, :LAT]))\nlocation_indices = Dict()\n\nfor row in eachrow(unique_locations)\n    if !ismissing(row.LON) && !ismissing(row.LAT)\n        # Point source - use coordinates\n        location_key = (row.COUNTRY, row.FIPS, row.LON, row.LAT)\n        location_indices[location_key] = GetIndex(row.LON, row.LAT, gd)\n    else\n        # Area source - use county polygon\n        location_key = (row.COUNTRY, row.FIPS, \"COUNTY\")\n        county_poly = findCountyPolygon(real_config.Counties, row.FIPS)\n        if county_poly !== nothing\n            location_indices[location_key] = GetIndex(county_poly, gd)\n        end\n    end\nend\n\n# Apply spatial allocation and write output\nprintln(\"Writing final gridded emissions...\")\n\noutput_records = []\nfor row in eachrow(final_emissions)\n    if !ismissing(row.Surrogate)\n        # Find appropriate surrogate data\n        spec = find_surrogate_by_code(sp.SrgSpecs, row.Surrogate)\n        if spec !== nothing\n            # Get location index\n            if !ismissing(row.LON) && !ismissing(row.LAT)\n                location_key = (row.COUNTRY, row.FIPS, row.LON, row.LAT)\n            else\n                location_key = (row.COUNTRY, row.FIPS, \"COUNTY\")\n            end\n\n            if haskey(location_indices, location_key)\n                index_info = location_indices[location_key]\n\n                # Apply surrogate allocation\n                surrogate_key = (spec.DataShapefile, spec.WeightShapefile)\n                if haskey(county_surrogates, surrogate_key)\n                    surrogate_data = county_surrogates[surrogate_key]\n\n                    # Distribute emissions to grid cells\n                    allocated = recordToGrid(\n                        row.ANN_VALUE,\n                        index_info,\n                        get(surrogate_data, row.FIPS, nothing)\n                    )\n\n                    # Store results for output\n                    for (cell_idx, emission_amount) in pairs(allocated.nzval)\n                        push!(output_records, (\n                            grid_cell = cell_idx,\n                            pollutant = row.POLID,\n                            emission_kg_s = emission_amount,\n                            source_fips = row.FIPS,\n                            source_scc = row.SCC\n                        ))\n                    end\n                end\n            end\n        end\n    end\nend\n\n# Convert to DataFrame and write shapefile\noutput_df = DataFrame(output_records)\nwriteEmis(\n    joinpath(real_config.EmisShp, \"nei2019_gridded_emissions.shp\"),\n    gd,\n    output_df,\n    real_config.OutputSR,\n    \"Final gridded 2019 NEI emissions\"\n)\n\nprintln(\"Processing complete!\")\nprintln(\"Output written to: $(real_config.EmisShp)\")\nprintln(\"Total gridded emission records: $(nrow(output_df))\")","category":"section"},{"location":"tutorial/#Performance-Considerations","page":"Complete Tutorial","title":"Performance Considerations","text":"For processing the full NEI dataset (~50GB total):\n\nMemory: 32-64GB RAM recommended for full domain processing\nStorage: ~200GB for input data, intermediate files, and outputs\nProcessing Time: 4-8 hours for complete CONUS domain at 1km resolution\nParallelization: Consider geographic tiling or surrogate-based parallelization\n\nFor smaller domains or testing, use geographic bounds to subset the processing area and reduce computational requirements.","category":"section"},{"location":"tutorial/#Key-Functions-Reference","page":"Complete Tutorial","title":"Key Functions Reference","text":"","category":"section"},{"location":"tutorial/#FF10-Data-Loading","page":"Complete Tutorial","title":"FF10 Data Loading","text":"FF10NonPointDataFrame() - Area source emissions (45 columns)\nFF10PointDataFrame() - Point source emissions (77 columns)\nFF10NonRoadDataFrame() - Non-road mobile emissions (45 columns)\nFF10OnRoadDataFrame() - On-road mobile emissions (45 columns)","category":"section"},{"location":"tutorial/#Configuration-and-Setup","page":"Complete Tutorial","title":"Configuration and Setup","text":"Config() - Main configuration structure\nsetupSpatialProcessor() - Initialize spatial processing","category":"section"},{"location":"tutorial/#Spatial-Allocation","page":"Complete Tutorial","title":"Spatial Allocation","text":"generate_data_sparse_matrices() - Load data shapefiles\ngenerate_weight_sparse_matrices() - Load weight shapefiles\ngenerate_countySurrogate() - Create allocation surrogates\nGetIndex() - Map locations to grid cells\nrecordToGrid() - Distribute emissions to cells","category":"section"},{"location":"tutorial/#Output-and-Utilities","page":"Complete Tutorial","title":"Output and Utilities","text":"writeEmis() - Write final gridded shapefile\nfind_surrogate_by_code() - Look up surrogate specifications\nUnit conversion constants: tonperyear, tonpermonth, foot, kelvin()\nPollutant mapping: Pollutants dictionary","category":"section"}]
}
